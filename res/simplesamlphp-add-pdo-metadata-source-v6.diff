Index: bin/importMetadataPdo.php
===================================================================
--- bin/importMetadataPdo.php	(revision 0)
+++ bin/importMetadataPdo.php	(working copy)
@@ -0,0 +1,23 @@
+<?php
+$baseDir = dirname(dirname(__FILE__));
+
+require_once $baseDir . DIRECTORY_SEPARATOR . 'lib' . DIRECTORY_SEPARATOR . '_autoload.php';
+require_once $baseDir . DIRECTORY_SEPARATOR . 'config' . DIRECTORY_SEPARATOR . 'config.php';
+
+foreach ($config['metadata.sources'] as $s) {
+    // we look for 'pdo' type
+    if ("pdo" === $s['type']) {
+        $mdshp = new SimpleSAML_Metadata_MetaDataStorageHandlerPdo($s);
+        $mdshp->initDatabase();
+        foreach (glob("metadata/*.php") as $filename) {
+            $metadata = array();
+            require_once $filename;
+            $set = basename($filename, ".php");
+            echo "importing set '$set'..." . PHP_EOL;
+            foreach ($metadata as $k => $v) {
+                echo "\t$k" . PHP_EOL;
+                $mdshp->addEntry($k, $set, $v);
+            }
+        }
+    }
+}
Index: config-templates/config.php
===================================================================
--- config-templates/config.php	(revision 3225)
+++ config-templates/config.php	(working copy)
@@ -499,7 +499,19 @@
 	 * - 'file': Path to the XML file with the metadata.
 	 * - 'url': The url to fetch metadata from. THIS IS ONLY FOR DEBUGGING - THERE IS NO CACHING OF THE RESPONSE.
 	 *
+	 * PDO metadata handler:
+	 * - 'type': This is always 'pdo'.
+	 * - 'dsn': This will be the full path to the database, see http://php.net/manual/en/pdo.drivers.php for your DB
+	 * - 'username': The username to use to connect to the database (OPTIONAL, default NULL)
+	 * - 'password': The password to use to connect to the database (OPTIONAL, default NULL)
+	 * - 'tablePrefix': The prefix for the database tables to use (OPTIONAL, defaults to no prefix)
+	 * - 'usePersistentConnection': Boolean specifying whether or not to use a persistent DB connection (OPTIONAL, default FALSE)
 	 *
+	 * You can use the script in bin/importMetadataPdo.php to import the existing flatfile metadata
+	 * into the PDO database. The tables will be created assuming your configuration is correct in this file.
+	 *
+	 *     $ php bin/importMetadataPdo.php
+	 *
 	 * Examples:
 	 *
 	 * This example defines two flatfile sources. One is the default metadata directory, the other
@@ -516,6 +528,11 @@
 	 *     array('type' => 'xml', 'file' => 'idp.example.org-idpMeta.xml'),
 	 *     ),
 	 *
+	 * This example defines a flatfile source and a PDO source.
+	 * 'metadata.sources' => array(
+	 *     array('type' => 'flatfile'),
+	 *     array('type' => 'pdo', 'dsn' => 'sqlite:/tmp/metadata.sqlite'),
+	 *     ),
 	 *
 	 * Default:
 	 * 'metadata.sources' => array(
Index: lib/SimpleSAML/Metadata/MetaDataStorageHandlerPdo.php
===================================================================
--- lib/SimpleSAML/Metadata/MetaDataStorageHandlerPdo.php	(revision 0)
+++ lib/SimpleSAML/Metadata/MetaDataStorageHandlerPdo.php	(working copy)
@@ -0,0 +1,154 @@
+<?php
+
+class SimpleSAML_Metadata_MetaDataStorageHandlerPdo extends SimpleSAML_Metadata_MetaDataStorageSource
+{
+    private $dsn;
+    private $pdo;
+    private $tablePrefix;
+
+    /**
+     * All the metadata sets simpleSAMLphp supports
+     */
+    public $supportedSets = array (
+        'adfs-idp-hosted',
+        'adfs-sp-remote',
+        'saml20-idp-hosted',
+        'saml20-idp-remote',
+        'saml20-sp-remote',
+        'shib13-idp-hosted',
+        'shib13-idp-remote',
+        'shib13-sp-hosted',
+        'shib13-sp-remote',
+        'wsfed-idp-remote',
+        'wsfed-sp-hosted'
+    );
+
+    public function __construct($config)
+    {
+        assert('is_array($config)');
+
+        $globalConfig = SimpleSAML_Configuration::getInstance();
+
+        $cfgHelp = SimpleSAML_Configuration::loadFromArray($config, 'pdo metadata source');
+
+        // determine the table prefix if one was set
+        $this->tablePrefix = $cfgHelp->getString('tablePrefix', '');
+        $this->dsn = $cfgHelp->getString('dsn');
+
+        $driverOptions = array();
+        if ($cfgHelp->getBoolean('usePersistentConnection', FALSE)) {
+            $driverOptions = array(PDO::ATTR_PERSISTENT => TRUE);
+        }
+
+        $this->pdo = new PDO($this->dsn, $cfgHelp->getValue('username', NULL), $cfgHelp->getValue('password', NULL), $driverOptions);
+        $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+    }
+
+    public function getMetadataSet($set)
+    {
+        if (!in_array($set, $this->supportedSets)) {
+            return array();
+        }
+        $tableName = $this->tablePrefix . $set;
+        $returnSet = array();
+
+        $stmt = $this->pdo->prepare("SELECT `entity_id`, `entity_data` FROM `$tableName`");
+        $result = $stmt->execute();
+        //if (FALSE === $result) {
+        //    throw new Exception("DB error: " . var_export($this->pdo->errorInfo(), TRUE));
+        //}
+        $data = $stmt->fetchAll(PDO::FETCH_ASSOC);
+        foreach ($data as $d) {
+            $returnSet[$d['entity_id']] = json_decode($d['entity_data'], TRUE);
+
+            // the 'entityid' key needs to be added to the entry itself...
+                if (preg_match('/__DYNAMIC(:[0-9]+)?__/', $d['entity_id'])) {
+                $returnSet[$d['entity_id']]['entityid'] = $this->generateDynamicHostedEntityID($set);
+            } else {
+                $returnSet[$d['entity_id']]['entityid'] = $d['entity_id'];
+            }
+
+        }
+
+        return $returnSet;
+    }
+
+    public function getMetaData($index, $set)
+    {
+        if (!in_array($set, $this->supportedSets)) {
+            return array();
+        }
+
+        $tableName = $this->tablePrefix . $set;
+
+        $stmt = $this->pdo->prepare("SELECT `entity_data` FROM `$tableName` WHERE `entity_id` = :entity_id");
+        $stmt->bindValue(":entity_id", $index, PDO::PARAM_STR);
+        $result = $stmt->execute();
+        //if (FALSE === $result) {
+        //    throw new Exception("DB error: " . var_export($this->pdo->errorInfo(), TRUE));
+        //}
+        $data = $stmt->fetch(PDO::FETCH_ASSOC);
+        $entry = json_decode($data['entity_data'], TRUE);
+
+        // the 'entityid' key needs to be added to the entry itself...
+        if (preg_match('/__DYNAMIC(:[0-9]+)?__/', $index)) {
+            $entry['entityid'] = $this->generateDynamicHostedEntityID($set);
+        } else {
+            $entry['entityid'] = $index;
+        }
+
+        return $entry;
+    }
+
+    private function generateDynamicHostedEntityID($set)
+    {
+        /* Get the configuration. */
+        $baseurl = SimpleSAML_Utilities::getBaseURL();
+
+        if ($set === 'saml20-idp-hosted') {
+            return $baseurl . 'saml2/idp/metadata.php';
+        } elseif ($set === 'saml20-sp-hosted') {
+            return $baseurl . 'saml2/sp/metadata.php';
+        } elseif ($set === 'shib13-idp-hosted') {
+            return $baseurl . 'shib13/idp/metadata.php';
+        } elseif ($set === 'shib13-sp-hosted') {
+            return $baseurl . 'shib13/sp/metadata.php';
+        } elseif ($set === 'wsfed-sp-hosted') {
+            return 'urn:federation:' . SimpleSAML_Utilities::getSelfHost();
+        } elseif ($set === 'adfs-idp-hosted') {
+            return 'urn:federation:' . SimpleSAML_Utilities::getSelfHost() . ':idp';
+        } else {
+            throw new Exception('Can not generate dynamic EntityID for metadata of this type: [' . $set . ']');
+        }
+    }
+
+    public function addEntry($index, $set, $entityData)
+    {
+        if (!in_array($set, $this->supportedSets)) {
+            return FALSE;
+        }
+        $tableName = $this->tablePrefix . $set;
+
+        $stmt = $this->pdo->prepare("INSERT INTO `$tableName` (`entity_id`, `entity_data`) VALUES(:entity_id, :entity_data)");
+        $stmt->bindValue(":entity_id", $index, PDO::PARAM_STR);
+        $stmt->bindValue(":entity_data", json_encode($entityData), PDO::PARAM_STR);
+        $stmt->execute();
+        //if (FALSE === $result) {
+        //    throw new Exception("DB error: " . var_export($this->pdo->errorInfo(), TRUE));
+        //}
+        return 1 === $stmt->rowCount();
+    }
+
+    public function initDatabase()
+    {
+        foreach ($this->supportedSets as $s) {
+            $tableName = $this->tablePrefix . $s;
+            $query = "CREATE TABLE IF NOT EXISTS `$tableName` (`entity_id` VARCHAR(255) PRIMARY KEY NOT NULL, `entity_data` TEXT NOT NULL)";
+            $result = $this->pdo->exec($query);
+            //if (FALSE === $result) {
+            //    throw new Exception("DB error: " . var_export($this->pdo->errorInfo(), TRUE));
+            //}
+        }
+    }
+
+}
Index: lib/SimpleSAML/Metadata/MetaDataStorageSource.php
===================================================================
--- lib/SimpleSAML/Metadata/MetaDataStorageSource.php	(revision 3225)
+++ lib/SimpleSAML/Metadata/MetaDataStorageSource.php	(working copy)
@@ -69,6 +69,8 @@
 				return new SimpleSAML_Metadata_MetaDataStorageHandlerDynamicXML($sourceConfig);
 			case 'serialize':
 				return new SimpleSAML_Metadata_MetaDataStorageHandlerSerialize($sourceConfig);
+			case 'pdo':
+				return new SimpleSAML_Metadata_MetaDataStorageHandlerPdo($sourceConfig);
 			default:
 				throw new Exception('Invalid metadata source type: "' . $type . '".');
 		}
@@ -226,4 +228,4 @@
 	}
 
 }
-?>
\ No newline at end of file
+?>
